# 字节

### 企业文化

追求极致

不断提高要求，延迟满足感

在更大范围里找最优解，不放过问题，思考本质

持续学习和成长

务实敢为

开放谦逊

坦诚清晰

始终创业

多元兼容



### 企业产品 

今日头条、抖音、抖音火山版、飞书、西瓜视频、懂车帝、幸福里、皮皮虾





### 前人经验：

1.向后端传数据的方式，向后端请求的一些方式（除了ajax之外），后端要怎么设置。

ajax提交



2.跨域是什么意思？为什么会有跨域，实现方式。 

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。任意两个不同就算跨域。

可以用websocket解决跨域。

CORS（Cross-Origin Resources Sharing）

nginx反向代理：

搭建一个中转nginx服务器，用于转发请求。

使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能。

实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。





3.怎么获取表单数据，element-UI的表单会怎么处理。 



4.session和cookie的区别，[前端]()存数据怎么存（紧张忘记了localStorage那些其实也不熟） 

session在服务器端，cookie在客户端。

session安全



5.上传图片怎么实现，原生JS写element-UI的照片墙你会怎么实现？ 





6.jQuery和vue的区别，对他们的认识，用原生JS替代jQuery，监听绑定事件，MySQL语句 



7.有没有学网络那些，七层模型，http版本，







8.闭包的应用，用来解决什么问题，谈谈理解 

**闭包**：有权访问另一个函数作用域中的变量的函数；一般情况就是在一个函数中包含另一个函数。





9.设计模式那些，单例模式解决什么，工厂模式（标准化？） 



10.接触[前端]()多久了，怎么学习[前端]()的知识 





11.promise





前天面里考了 Promise.all ，实现Promise.run（跟all一样但是串行），进而实现koa2的洋葱模型



12.v-if和v-show的区别

表达式为true时都会占据页面位置，false时都不会占据页面位置。

v-show是通过增加元素css--display:none，dom元素还在，有更高的初始消耗，不会触发组件生命周期，v-if则是将dom元素增加或删除，因此v-if有更高的切换消耗，且会触发组件的生命周期。

频繁切换用v-show，条件不怎么改变用v-if



13.TCP和UDP区别



14.TCP可靠性原理



15.第四次挥手[客户端]()TIME_WAIT的时候网络断了，[客户端]()和服务端的后续（服务端不太清楚，面试官是挺有意思的可以去了解一下）



16.http和https的区别，SSL加密的过程？ 

1、http是超文本传输协议，其中的信息是明文传输的。https是http协议再加上SSL（安全套接字层），具有安全性。

2.http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。



SSL加密过程

l 客户端向服务器索要并验证服务器的公钥。

l 双方协商生产「会话秘钥」。

l 双方采用「会话秘钥」进行加密通信。



17.ES6新特性

新增了let和const

解构赋值：可以从数组或对象中获取值。

模板字符串：`${}`中可以使用任意的javaScript表达试、运算、引用对象属性、函数调用等。结果是其返回值。可以换行，但是所有的空格和换行会被保留。

函数扩展...

数组扩展...

增加了set和map





18.let，const和var的区别？为什么let和var会有这样的不同？

var作用域：函数内为函数上下文，否则全局。可以反复声明。存在变量提升（变量可以在声明之前调用）。不存在暂时性死区。

let：只在声明的代码块中有效。不允许重复声明。不存在变量提升（变量可以在声明之前调用）。存在暂时性死区。

const：只在声明的代码块中有效。不允许重复声明。只读常量，必须一开始初始化。指向的内存地址保存的数据不得改动。不存在变量提升（变量可以在声明之前调用）。存在暂时性死区。



19.网络七层模型及协议



20.应用udp的协议



21.浏览器缓存



22.类组件与函数组件对比



23.双向绑定的理解

单向绑定非常简单，就是把model绑定到view，更新model时view也就被更新；

双向绑定就是在用户更新view时更新model。

- 数据变化后更新视图
- 视图变化后更新数据



24.水平垂直居中

行内元素：给父元素设置`text-align:center`

块级元素：定宽：`margin:0 auto`

​				不定宽：





25.为什么要三次握手

（1）三次握手才可以阻止重复历史连接的初始化（主要原因）

（2）三次握手才可以同步双方的初始序列号

（3）三次握手才可以避免资源浪费

TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。

**不使用「两次握手」和「四次握手」的原因：**

「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；

「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。



26.三次握手哪一次最容易被攻击？

第二次。黑客仿造IP大量的向server发送TCP连接请求报文包，从而将server的半连接队列（上文所说的未连接队列，即server收到连接请求SYN之后将client加入半连接队列中）占满，从而使得server拒绝其他正常的连接请求。即拒绝服务攻击。





27.四次挥手



28.bind apply 



29.TCP和UDP区别

![image-20210915151615156](C:\Users\SNORLAX\AppData\Roaming\Typora\typora-user-images\image-20210915151615156.png)





30.HTTP的演化

**HTTP1.1相比HTTP1.0的优化**

\1.   HTTP1.1支持长连接和请求的流水线处理

HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

HTTP 1.1则**支持持久连接**Persistent Connection, 并且默认使用persistent connection。在同一个TCP的连接中可以传送多个HTTP请求和响应。多个请求和响应可以重叠，多个请求和响应可以同时进行。更加多的请求头和响应头(比如HTTP1.0没有host的字段)。

HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。

请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。例如：一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。 HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容。

\2.   支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

\3.   HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。

\4.   HTTP1.1增加host字段

在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。

HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。

\5.   100（Continue）Status（节约带宽）

HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。

\6.   HTTP/1.1中引入了Chunked transfer-coding

发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。

\7.   HTTP/1.1在1.0的基础上加入了一些cache的新特性

当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活。



**HTTP2针对HTTP1.1的优化**

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

\1. 头部压缩

HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

\2. 二进制格式

HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。

\3. 数据流

HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为一个数据流（ Stream ）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。

\4. 多路复用

HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。

\5. 服务器推送

HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。



HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！





字节实习一面：

第一次做面试，面试官是个女性，人还是蛮好的，即使我说错了也会说“好的”，我尴尬得大汗淋漓……

虽然因为做项目的时候做前端所以面的前端，但其实对js，css都不大熟悉……难为面试官了，不过我都这样了，面试官还要问我”是这样吗“，我掉了好几次陷阱，改错了好几个题……



自我介绍



1.span标签可以设置宽高吗？那margin和padding呢？

span标签不能设置宽高，但可以通过`display:block`改变宽高。

margin和padding无效，只有margin-left,margin-right,padding-left,padding-right有效。



2.项目里用到了什么标签





3.手动实现jquery的ajax



4.传输数据的方式



5.说几个请求状态码



6.进程和线程的区别



7.线程有几种状态

创建、就绪、运行、阻塞、死亡。



8.body的默认大小



9.box-sizing属性有使用过吗



10.BFC是什么？有使用过吗？



11.有用过setTimeOut吗？



12.let和var的区别？



13.块级作用域是什么？



14.js静态作用域和动态作用域





js作用域

作用域指的是有权访问的变量集合。

词法作用域，函数的作用域在函数定义的时候就决定了。

动态作用域，函数的作用域是在函数调用的时候才决定。



代码：

1.在div（有id）标签中加入10个p标签。

参考答案





2.写一个footer，固定在屏幕下方。不要有滚动条。

3.一个有padding ，border，margin的box问有颜色的部分宽高。

4.1s输出1个数组元素。

5.会输出什么？

```js
let a="lili"
{
    console.log(a);
    a="mimi"
}
```

应该输出lili



6.问输出结果（大概是这样一个题）

```js
var s="window"

function say()
{
    console.log(s);
    console.log(this.s);
}

var s1={
    s:"1-1",
    say:function ()
    {
        s="1-2";
        console.log(s);
        console.log(this.s);
    }
}

var s2={
    s:"2-1",
    say:function ()
    {
        s="2-2";
        console.log(s);
        console.log(this.s);
    }
}

    say();
    s1.say();
    s2.say();
    s1.say=say;
    s1.say();
    s1.say=s2.say;
    s1.say();


```







7.问输出结果（大概是这样一个题）

```js
function foo(){
    getName()
    {
        alert("1");
    }
    return this;
}

    foo.getName=function() {alert("2");};
    foo.prototype.getName=function() {alert("3");};
    
    var getName = function() {alert("4")};
    function getName() {alert("5")};    
	
	getName;
    getName();
    foo.getName();
    new foo.getName();
    new foo().getName();


```









